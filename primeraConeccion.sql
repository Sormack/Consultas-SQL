--Script para la base de datos 
/*
Tipos de bases de datos
Los relacionales y no relacionales

3 Tipos de sentencia de codigo de SQL
--DDL --Lenguaje de deficion de datos 
--DML --Lenguaje de manipulacion de datos
--DCL --Lenguaje de control de datos
-*

/*
Puntos iumportantes del gesto de bases de datos de oracle
Se puede utilizar el guion bajo para el nombre de las tablas y los campos:ID_Empleado
No utilizar el camelcase 
El nombre de las tablas y los campos y palabras reservadas van de mayusculas 
El nombre de las tablas puden ir en singular o plural
El nombre de los campos simpre van en singular 
*/

--Existen tres maneras de crear las tablas 
CREATE TABLE PROVEEDOR(
ID NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(80),
APELLIDO_PATERNO VARCHAR2(80),
APELLIDO_MATERNO VARCHAR(80)
);

--Agregando un nuevo registro
INSERT INTO PROVEEDOR VALUES(1,'JAVIER','ESPINOSA','GOMEZ');
--Mostrando los registros 
SELECT * FROM PROVEEDOR;

--Segunda forma de crear tablas
CREATE TABLE PRODUCTOS(
ID NUMBER,
NOMBRE VARCHAR2(80),
CATEGORIA VARCHAR2(80),--Bebidas,Galletas,Botanas
EXISTENCIA INT,
PRECIO NUMBER,
CADUCIDAD DATE,
PRIMARY KEY(ID)
);

INSERT INTO PRODUCTOS VALUES(1,'BARRITAS','GALLETAS',4,15.3,'18/09/2029');
INSERT INTO PRODUCTOS VALUES(2,'DORITOS PIZZEROLA', 'BOTANAS', 60, 19, '15/11/2025');
INSERT INTO PRODUCTOS VALUES(3,'PINGÜINOS', 'PASTEL', 20, 17.5, '09/03/2026');
INSERT INTO PRODUCTOS VALUES(4,'COCA-COLA ZERO', 'BEBIDAS', 100, 20, '15/07/2025');
INSERT INTO PRODUCTOS VALUES(5,'SUAVICREMAS', 'GALLETAS', 30, 14, '03/10/2025');
INSERT INTO PRODUCTOS VALUES(6,'CHEETOS TORCIDITOS', 'BOTANAS', 37, 43, '28/05/2025');
INSERT INTO PRODUCTOS VALUES(7,'MONSTER', 'BEBIDAS', 21, 35, '06/04/2025');
INSERT INTO PRODUCTOS VALUES(8,'TOSTITOS', 'BOTANAS', 37, 12.5, '07/08/2025');

INSERT INTO PRODUCTOS VALUES(9, 'CHOCOLATE', 'DULCES', 10, 25.5, '22/11/2027');  
INSERT INTO PRODUCTOS VALUES(10, 'GALLETAS SALADAS', 'GALLETAS', 7, 12.0, '05/06/2028');  
INSERT INTO PRODUCTOS VALUES(11, 'JUGO DE NARANJA', 'BEBIDAS', 20, 18.7, '14/02/2026');  
INSERT INTO PRODUCTOS VALUES(12, 'PAPAS FRITAS', 'BOTANAS', 15, 22.3, '30/08/2027');  
INSERT INTO PRODUCTOS VALUES(13, 'AGUA MINERAL', 'BEBIDAS', 25, 10.5, '12/12/2030');  
INSERT INTO PRODUCTOS VALUES(14, 'CAFÉ MOLIDO', 'BEBIDAS', 8, 35.0, '20/07/2029');  
INSERT INTO PRODUCTOS VALUES(15, 'YOGURT NATURAL', 'LÁCTEOS', 12, 19.9, '03/04/2026');  


SELECT * FROM PRODUCTOS;

--Tercera forma
CREATE TABLE EMPLEADOS(
ID NUMBER,
NOMBRE NVARCHAR2(80),
APELLIDO_PATERNO NVARCHAR2(80),
APELLIDO_MATERNO NVARCHAR2(80),
DEPARTAMENTO NVARCHAR2(80),
SUELDO NUMBER,
CONSTRAINT PK_EMPLEADOS PRIMARY KEY(ID)
);

INSERT INTO EMPLEADOS VALUES (1,'JOSE','LOZANO','PEREZ','SISTEMAS',23000);
INSERT INTO EMPLEADOS VALUES (2, 'MARIA', 'GONZALEZ', 'RAMIREZ', 'RECURSOS HUMANOS', 25000);
INSERT INTO EMPLEADOS VALUES (3, 'CARLOS', 'FERNANDEZ', 'LOPEZ', 'FINANZAS', 28000);
INSERT INTO EMPLEADOS VALUES (4, 'ANA', 'MARTINEZ', 'TORRES', 'MARKETING', 26000);
INSERT INTO EMPLEADOS VALUES (5, 'PEDRO', 'HERRERA', 'MORALES', 'VENTAS', 24000);
INSERT INTO EMPLEADOS VALUES (6, 'LAURA', 'RODRIGUEZ', 'GOMEZ', 'ADMINISTRACION', 27000);
INSERT INTO EMPLEADOS VALUES (7, 'LUIS', 'NAVARRO', 'SANCHEZ', 'LOGISTICA', 25500);
INSERT INTO EMPLEADOS VALUES (8, 'ELENA', 'CASTILLO', 'DELGADO', 'ATENCION AL CLIENTE', 24500);

INSERT INTO EMPLEADOS VALUES(9,'JUAN', 'GUTIERREZ', 'MENDIOLA', 'VENTAS', 18000);
INSERT INTO EMPLEADOS VALUES(10,'RICARDO', 'MENDOZA', 'AVILA', 'VENTAS', 18000);
INSERT INTO EMPLEADOS VALUES(11,'ESTEFANIA', 'RIVERA', 'SOTO', 'RECURSOS HUMANOS', 25000);
INSERT INTO EMPLEADOS VALUES(12,'DULCE', 'VELAZUEZ', 'ECHEVERRIA', 'FINANZAS', 16000);
INSERT INTO EMPLEADOS VALUES(13,'JAIR', 'JIMENEZ', 'HERNANDEZ', 'RECURSOS HUMANOS', 25000);
INSERT INTO EMPLEADOS VALUES(14,'CANDELARIA', 'RAMIREZ', 'RIOS', 'MARKETING', 25000);
INSERT INTO EMPLEADOS VALUES(15,'ISABEL', 'GUERRERO', 'ACOSTA', 'VENTAS', 18000);

SELECT * FROM EMPLEADOS;

--SQL devoloper es una herramienta de oracle que nos alluda a desarrollar y administra BD de oracle
--Consultas basicas --Usando DML

--Mostrando todos los registros de la tabla y todos  lo campos
SELECT * FROM EMPLEADOS;
--Mostrando solo algunos de los campos de la tabla
SELECT NOMBRE,APELLIDO_PATERNO,SUELDO FROM EMPLEADOS;
--Mostrando los registros que tengan el nombre de luis --Condicion de busqueda
SELECT * FROM EMPLEADOS WHERE NOMBRE = 'LUIS';
--Atualizando un registro
UPDATE EMPLEADOS SET NOMBRE ='MARIA' WHERE ID =8;
SELECT * FROM EMPLEADOS WHERE ID =8;
--Eliminando un registro 
DELETE PRODUCTOS WHERE ID = 15;
--Operador logico OR
SELECT * FROM EMPLEADOS WHERE DEPARTAMENTO = 'SISTEMAS' OR SUELDO = 25000; 
--Operador logico AND
SELECT * FROM EMPLEADOS WHERE DEPARTAMENTO = 'SISTEMAS' AND SUELDO = 23000;
--Evaluando un rango de valores IN
SELECT * FROM EMPLEADOS WHERE ID IN(2,5,10); 
--Evaluando un rango de valores cosecutivos 
SELECT * FROM EMPLEADOS WHERE ID BETWEEN 5 AND 10;
--Buscando por coincidencia de caracteres
--AL INICO
SELECT  * FROM EMPLEADOS WHERE NOMBRE LIKE 'A%';
--ALFINAL 
SELECT  * FROM EMPLEADOS WHERE NOMBRE LIKE '%A';
--QUE LO CONTENGA EL NOMBRE
SELECT  * FROM EMPLEADOS WHERE NOMBRE LIKE '%A%';


--SUBCONSULTAS --SON CONSULTAS DENTRO DE OTRA
SELECT ID FROM EMPLEADOS WHERE ID = (SELECT COUNT(ID) FROM EMPLEADOS); 
--MAYOR SUELDO
SELECT * FROM EMPLEADOS WHERE SUELDO=(SELECT MAX(SUELDO) FROM EMPLEADOS);
--MENOR SUELDO
SELECT * FROM EMPLEADOS WHERE SUELDO=(SELECT MIN(SUELDO) FROM EMPLEADOS);

--CONCAT --SIRVE PARA COCATENAR PALABRAS EN LOS CAMPOS DE LA TABLAS 
SELECT NOMBRE, APELLIDO_PATERNO, CONCAT(SUELDO,'PESOS')AS SUELDO FROM EMPLEADOS;

--AGRUPAR POR DEPDATAMENTO--EL GRUOP BY SE USA CON EL COUNT 
SELECT DEPARTAMENTO, COUNT(*) FROM EMPLEADOS GROUP BY DEPARTAMENTO;

--MOSTRANDO LOS REGISTROS DE LA TABLA Y ORDENAR DE MANERA ACENDENTE Y DECENDENTE  
SELECT * FROM EMPLEADOS ORDER BY NOMBRE DESC;
SELECT * FROM EMPLEADOS ORDER BY NOMBRE ASC;

--SACANDO EL PROMEDIO
SELECT AVG(SUELDO) AS PROMEDIO FROM EMPLEADOS WHERE DEPARTAMENTO = 'VENTAS';

--Consultas con la tabla de productos 
--Mostrando todo los registros 
SELECT * FROM PRODUCTOS;
--Mostrar los productos de la categoria gelletas
SELECT * FROM PRODUCTOS WHERE CATEGORIA = 'GALLETAS';
--Contar cunatos productos hay por categoria 
SELECT CATEGORIA,COUNT(*) FROM PRODUCTOS GROUP BY CATEGORIA;
--Sacar promedio de los productos mayores a 18
SELECT AVG(PRECIO) AS PROMEDIO FROM PRODUCTOS WHERE PRECIO > 18;
--Sumar el precio de todos los productos de la categoria bebidas
SELECT SUM(PRECIO) FROM PRODUCTOS WHERE CATEGORIA = 'BEBIDAS';
--Agrupar productos por caducidad
SELECT NOMBRE,CADUCIDAD FROM PRODUCTOS;
--Mostrar el producto mas caro
SELECT * FROM PRODUCTOS WHERE PRECIO = (SELECT MAX(PRECIO) FROM PRODUCTOS); 
--Mostrar el producto mas barato
SELECT * FROM PRODUCTOS WHERE PRECIO = (SELECT MIN(PRECIO) FROM PRODUCTOS); 
--Concatenar la palabra pesos en el precio
SELECT NOMBRE,CONCAT(PRECIO,'PESOS')AS SUELDO FROM PRODUCTOS;
--Mostrar los registros del id 5 a 10
SELECT * FROM PRODUCTOS WHERE ID BETWEEN 5 AND 10;
--Buscar los productos donde el nombre inicie con c
SELECT * FROM PRODUCTOS WHERE NOMBRE LIKE  'C%';
--Ordenar los productos por el nombre asc
SELECT * FROM PRODUCTOS ORDER BY  NOMBRE ASC;

---Validacion de los campos de las tablas
CREATE TABLE PERFUME(
    ID NUMBER PRIMARY KEY,--YA ESTA VALIDADO PARA NO ACEPTAR VALORES NULOS
    MARCA VARCHAR2(80) NOT NULL,
    PPRECIO NUMBER --TOMA UN VALOR POR  DEFAUL EL NULL
);

INSERT INTO PERFUME VALUES(1,'JAFRA',900);
INSERT INTO PERFUME VALUES(2,'JAFRA',NULL);

COMMIT;
--MOSTRAR LOS PERFUMES DONDE LOS VALORES NO SEAN NULOS
SELECT * FROM PERFUME WHERE PPRECIO IS NOT NULL;
---MOSTRA LOS PERFUMES DONDE LOS VALORES SEAN NULOS
SELECT * FROM PERFUME WHERE PPRECIO IS NULL;

----Commit(INSERT,UPDATE,O DELATE)sirve para la persistencia de datos
----Se realiza las operaciones de manera efectiva 
----Los cambios se veran reflejados en el motor de la base de datos(Disco local c)
----SQL developer solo es el ejecutable

---Eliminando los registros de la tabla perfume, DELETE no contiene el commit 
DELETE FROM PERFUME;

---Rollback permite recuperar los registros eliminados siempre y cuando no esten los registro
---eliminados con el commit 
ROLLBACK;

SELECT * FROM PERFUME;
---EL DROP  TIENE EL COMMIT  
---TRUNCATE--Es para eliminar los registros de una tabla, ya tiene el commit 
TRUNCATE TABLE PERFUME;

----Creacion de mas de una tabla
---Cardinalidad o relacin de 1:1,1:N,N:1,N:N(creando una nueva tabla para romper la relacion )
---La normalizacion de la base de datos ---Para evitar la redundancia de los datos -- A la duplicidad da datos
--1 FN,2FN y 3FN

---Cardinalidad el como se relaciona las tablas
--Tablas fuertes(Independientes)
--Tablas debiles(Deppendientes)

--Siempre hay que empezar con las tablas fuertes--Solomente contienen llave primaria no foranes

--Cardinalidad 1:1--Se tiene la opcion de de donde va  ir la llave foranea
--Empleados -- INE
CREATE TABLE EMPLEADOS_DOS(
ID NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(80) NOT NULL,
APELLIDO_PATERNO VARCHAR2(80) NOT NULL,
APELLIDO_MATERNO VARCHAR2(90)
);

INSERT INTO EMPLEADOS_DOS VALUES(1,'JOSE','MENDOZA','TORRES');
INSERT INTO EMPLEADOS_DOS VALUES(2,'ALAN','GONZALES','TORRES');
COMMIT;

CREATE TABLE INE(
ID NUMBER PRIMARY KEY,
CLAVE VARCHAR2(18) NOT NULL,
FECHA_REGISTRO DATE NOT NULL,
ID_EMPLEADO NUMBER NOT NULL UNIQUE,--VALIDAR QUE ESTE CAMPO NO SE REPITA
FOREIGN KEY(ID_EMPLEADO) REFERENCES EMPLEADOS_DOS(ID)
);

INSERT INTO INE VALUES(1,'321ASDSDA','12/09/2014',1);

--EL INNER JOIN BUSCA LAS COICIDENCIAS
SELECT * FROM EMPLEADOS_DOS INNER JOIN INE ON EMPLEADOS_DOS.ID = INE.ID_EMPLEADO;
--PONIENDO ALIAS
SELECT E.NOMBRE,I.CLAVE AS CLAVE_DEL_LECTOR FROM EMPLEADOS_DOS E INNER JOIN INE I ON E.ID = I.ID_EMPLEADO;
SELECT E.NOMBRE,I.CLAVE AS CLAVE_DEL_LECTOR FROM EMPLEADOS_DOS E INNER JOIN INE I ON E.ID = 1 ORDER BY E.NOMBRE;

--PARA MOSTRAR TOODOS LOS REGISTROS DE LA TABLA EMPLEADOS
SELECT * FROM EMPLEADOS_DOS LEFT JOIN INE ON EMPLEADOS_DOS.ID= INE.ID_EMPLEADO; 

---CARDINALIDAD UNO A MUCH0S ---LA LLAVE FORANEA SIMPRE VA EN  LA TABLA DE MUCHOS
-- 1  CATEGORIA TABLA FUERTE IDEPENDIENTE ---*LIBROS LLEVA  LA LLAVE FORANEA Y ES LA TABLA DEBIL
CREATE TABLE CATEGORIAS(
ID NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(80) NOT NULL
);

INSERT INTO CATEGORIAS VALUES(1,'CIENCIA FICCION');
COMMIT;

CREATE TABLE LIBROS(
ID NUMBER PRIMARY KEY,
TITULO VARCHAR2(80)NOT NULL,
NUM_PAG INT NOT NULL,
FK_CATEGORIAS NUMBER NOT NULL,
FOREIGN KEY (FK_CATEGORIAS) REFERENCES CATEGORIAS(ID)
);

INSERT INTO LIBROS VALUES(1,'DUNE',450,1);
INSERT INTO LIBROS VALUES(2,'GUERRA DE LOS MUNDOS',205,1);
COMMIT;

----CONSULTA PARA MOSTRAR LOS 2 REGISTROS
SELECT * FROM CATEGORIAS C INNER JOIN LIBROS L ON C.ID = L.FK_CATEGORIAS;

SELECT * FROM CATEGORIAS C FULL JOIN LIBROS L ON C.ID = L.FK_CATEGORIAS;

-----------------------Ejercicio  clientes y pedidos--------------

CREATE TABLE CLIENTES(
ID_CLIENTE NUMBER PRIMARY KEY,
NOMBRE VARCHAR(80)NOT NULL,
NUMERO INT NOT NULL
);

CREATE TABLE PEDIDOS(
ID_PEDIDO NUMBER PRIMARY  KEY,
FACTURA VARCHAR(80) NOT NULL,
FK_CLIENTE NUMBER NOT NULL,
FOREIGN KEY(FK_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE)
);

INSERT INTO CLIENTES VALUES(1,'MARCO LAMBERT',45643552); 
INSERT INTO CLIENTES VALUES(2,'LYDIA RODERIC',44533221); 
INSERT INTO CLIENTES VALUES(3,'EBBE THERESE',488982635); 
INSERT INTO CLIENTES VALUES(4,'SOFIE MARIONA',412436773); 
COMMIT;

INSERT INTO  PEDIDOS VALUES(234,160,4);
INSERT INTO  PEDIDOS VALUES(235,48,2);
INSERT INTO  PEDIDOS VALUES(236,64,3);
INSERT INTO  PEDIDOS VALUES(237,92,4);
COMMIT;

---INNER JOIN MOSTRANDO TODO LOS CLIENTES COM PEDIDOS Y ORDENADOS POR NOMBRE
SELECT C.NOMBRE,P.ID_PEDIDO FROM CLIENTES C INNER JOIN PEDIDOS P ON C.ID_CLIENTE = P.FK_CLIENTE ORDER BY C.NOMBRE;

---LEFT JOIN MOSTRAR TODOS LOS CLIENTES Y CUALQUIER PEDIDO QUE PUDIERA ENCARGAR 
SELECT C.NOMBRE,P.ID_PEDIDO FROM CLIENTES C LEFT JOIN PEDIDOS P ON C.ID_CLIENTE = P.FK_CLIENTE ORDER BY C.NOMBRE;
---RIGHT JOIN 
SELECT P.ID_PEDIDO,C.NOMBRE FROM CLIENTES C  RIGHT JOIN PEDIDOS P ON C.ID_CLIENTE = P.FK_CLIENTE ORDER BY P.ID_PEDIDO ASC;
---FULL JOIN TODOS LAS FILAS DE  LA TABLA CLIENTE Y PEDIDO ORDENADO POR CLIENTE 
SELECT * FROM CLIENTES C FULL JOIN PEDIDOS P ON C.ID_CLIENTE = P.FK_CLIENTE ORDER BY C.NOMBRE;

----Cardinalida de muchos muchos
CREATE TABLE  ALUMNOS(
ID NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(80) NOT NULL,
APP VARCHAR2(90) NOT NULL,
APM VARCHAR2(90)
);

CREATE TABLE MATERIAS(
ID NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(90),
HORA_INICIO DATE NOT NULL,
HORA_FIN DATE NOT NULL
);

CREATE TABLE ALUMS_MATERIAS(
ID NUMBER PRIMARY KEY,
FK_ALUMNO  NUMBER NOT NULL,
FOREIGN KEY(FK_ALUMNO) REFERENCES ALUMNOS(ID),
FK_MATERIA NUMBER NOT NULL,
FOREIGN KEY(FK_MATERIA) REFERENCES MATERIAS(ID)

);

--AGREGAR DOS REGISTROS POR TABLAS
INSERT  INTO ALUMNOS VALUES(1,'JOSE','TORRES','ESTRADA');
INSERT  INTO ALUMNOS VALUES(2,'MARIA','GONZALES','MIRANDA');

/*INSERT INTO MATERIAS VALUES(1,'MATEMATICAS',TO_DATE('2000-03-18 12:48:04','YYYY-MM-DD HH24:MI:SS'),
                            TO_DATE('2000-03-18 13:48:04','YYYY-MM-DD HH24:MI:SS'));

INSERT INTO MATERIAS VALUES(2,'HISTORIA',TO_DATE('2000-03-18 3:45:04','YYYY-MM-DD HH24:MI:SS'),
                            TO_DATE('2000-03-18 6:00:45','YYYY-MM-DD HH24:MI:SS'));
*/
INSERT INTO MATERIAS VALUES(1,'MATEMATICAS',TO_DATE('12:48:04','HH24:MI:SS'),
                            TO_DATE('13:48:04','HH24:MI:SS'));
                            
INSERT INTO MATERIAS VALUES(2,'HISTORIA',TO_DATE('14:48:04','HH24:MI:SS'),
                            TO_DATE('15:48:04','HH24:MI:SS'));   
COMMIT;
DELETE FROM MATERIAS;
SELECT * FROM MATERIAS;

INSERT INTO ALUMS_MATERIAS VALUES(1,1,2);
INSERT INTO ALUMS_MATERIAS VALUES(2,2,1);

--MOSTRAR LA INFORMACION DE LAS TRES TABLAS
//SELECT * FROM ALUMS_MATERIAS AM JOIN ALUMNOS A ON AM.FK_ALUMNO = A.ID JOIN MATERIAS M ON AM.FK_MATERIA = M.ID;

SELECT A.NOMBRE AS NOMBRE_ALUMNO,A.APP,M.NOMBRE AS NOBRE_MATERIA,
TO_CHAR(M.HORA_INICIO,'HH24:MI:SS')AS HORA_INICIOM,TO_CHAR(M.HORA_FIN,'HH24:MI:SS') AS HORA_FIN,AM.ID
FROM ALUMNOS A INNER JOIN ALUMS_MATERIAS AM ON A.ID= AM.FK_ALUMNO 
INNER JOIN MATERIAS M ON M.ID = AM.FK_MATERIA;



-------------------Triggers es un disparador de eventos (eventos como insert uodate delete )
---Su funcions mas importante del trigger es mantener la integridad de la la informacion
---Es un objeto qie asoscia a una tabla y se ejecuta de manera autonoma cuando sucede algo en la BD
---PLSQL --Son bloques de codigo SQL que ya tienen una estructura 

---simulandondo una bitacora de historial 
CREATE TABLE COMIDAS(
ID NUMBER PRIMARY KEY NOT NULL,
NOMBRE VARCHAR2(50) NOT  NULL,
PRECIO NUMBER NOT NULL,
CADUCIDAD DATE NOT  NULL
);

INSERT INTO COMIDAS VALUES(1,'TESMOLE',250,'29/03/2025');
COMMIT;

SELECT * FROM BITACORA_HISTORIAL_COMIDA;

DELETE FROM COMIDAS;

CREATE TABLE BITACORA_HISTORIAL_COMIDA(
USUARIO VARCHAR2(80) NOT NULL,
FECHA DATE NOT NULL,
OPERACION VARCHAR2(80)
);

-------GENERAR LA LLAVE PRIMARIA COMO AUTO INCREMENTABLE 
CREATE TABLE AUTOS(
ID NUMBER PRIMARY KEY,
PLACA VARCHAR2(80) NOT NULL,
PRECIO NUMBER NOT NULL,
COLOR VARCHAR2(80) NOT NULL
);

INSERT INTO AUTOS (PLACA,PRECIO,COLOR)VALUES('SADD321',23569,'ROJO');
INSERT INTO AUTOS (PLACA,PRECIO,COLOR)VALUES('SADDADSA',2323069,'AZUL');

SELECT * FROM AUTOS;
----SECUENCIA GENERA UNA SERIE DE NUMEROS CONSECUTIVOS 
---SE USAN PARA GENERAR LOS AUTOINCREMNEABLES

CREATE SEQUENCE SECUENCIA_AUTOS
START WITH 1
INCREMENT BY 1;

---TRIGGER 
CREATE OR  REPLACE TRIGGER EJECUTAR_SECUENCIA
BEFORE INSERT 
ON AUTOS 
FOR EACH ROW 
BEGIN 
    SELECT SECUENCIA_AUTOS.NEXTVAL INTO :NEW.ID FROM DUAL;
END;

//DROP TABLE CASA;

CREATE TABLE CASA(
ID_CASA NUMBER PRIMARY KEY,
ESTADO VARCHAR2(80),
CODIGO_POSTAL INT NOT NULL,
MUNICIPIO VARCHAR2(80)
);

CREATE SEQUENCE ID_AUTOINCREMENTABLE_CASA
START WITH 1
INCREMENT BY 1;

CREATE OR  REPLACE TRIGGER EJECUTAR_SECUENCIA_CASA
BEFORE INSERT 
ON CASA
FOR EACH ROW 
BEGIN 
    SELECT ID_AUTOINCREMENTABLE_CASA.NEXTVAL INTO :NEW.ID_CASA FROM DUAL;
END;

INSERT INTO CASA(ESTADO,CODIGO_POSTAL,MUNICIPIO) VALUES('MEXICO',54469,'NICOLAS ROMERO');
INSERT INTO CASA(ESTADO,CODIGO_POSTAL,MUNICIPIO) VALUES('MEXICO',54458,'ATIZAPAN DE ZARAGOZA');
SELECT * FROM CASA;

CREATE TABLE HABITANTE(
ID_HABITANTE NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(80),
APELLIDO_PATERNO VARCHAR2(80),
FK_CASA NUMBER NOT NULL,
FOREIGN KEY (FK_CASA) REFERENCES CASA(ID_CASA)
);

CREATE SEQUENCE ID_AUTOINCREMENTABLE_HABITANTE
START WITH 1
INCREMENT BY 1;

CREATE OR  REPLACE TRIGGER EJECUTAR_SECUENCIA_HABITANTE
BEFORE INSERT 
ON HABITANTE
FOR EACH ROW 
BEGIN 
    SELECT ID_AUTOINCREMENTABLE_HABITANTE.NEXTVAL INTO :NEW.ID_HABITANTE FROM DUAL;
END;

INSERT INTO HABITANTE(NOMBRE,APELLIDO_PATERNO,FK_CASA)VALUES('JOSE','ESTRADA',1);
INSERT INTO HABITANTE(NOMBRE,APELLIDO_PATERNO,FK_CASA)VALUES('ROBERTI','TORRES',2);

SELECT * FROM HABITANTE;

SELECT * FROM CASA C INNER JOIN HABITANTE H ON C.ID_CASA = H.FK_CASA;

----ALTER---PERMITE MODIFICAR LOS CAMPOS Y RESTRICCIOENES DE LA TABLA 

CREATE TABLE CANASTA(
ID NUMBER,
NOMBRE VARCHAR2(80)NOT NULL
);

---AGREAGANDO NUEVOS CAMPOS A LA TABLA
ALTER TABLE CANASTA 
ADD PRECIO NUMBER;

ALTER TABLE CANASTA 
ADD(COLOR VARCHAR2(70),TAMANIO VARCHAR2(80));

SELECT * FROM CANASTA;

---ELIMIANDO CAMPOS EN LA TABLA
ALTER TABLE CANASTA
DROP COLUMN PRECIO;

ALTER TABLE CANASTA
DROP (COLOR,TAMANIO);

----AGRAGANDO UNA RESTRICCION
ALTER TABLE CANASTA 
ADD CONSTRAINT PK_CANASTA
PRIMARY KEY(ID);

INSERT INTO CANASTA VALUES(1,'QUESERA'); 
COMMIT;

ALTER TABLE CASA
DROP COLUMN ESTADO;

ALTER TABLE CASA RENAME TO ESTADO;

ALTER TABLE ESTADO RENAME COLUMN ID_CASA TO ID_ESTADO;

ALTER TABLE ESTADO 
ADD NOMBRE VARCHAR2(80);

SELECT * FROM CANASTA;
//ACTULIZACION DE REGISTROS
UPDATE CANASTA SET PRECIO = 500 WHERE ID=1;
COMMIT;

INSERT INTO CANASTA VALUES(2,'PASTELERA',200); 
INSERT INTO CANASTA VALUES(3,'AMACA',200); 
COMMIT;

---VISTAS O VIEW --SON TABLAS VIRTUALES QUE ALMACENAN UNA CONSULTA MUY EXTENSA ----PARA REPORTES 
CREATE OR REPLACE VIEW VIEW_CANASTA_MAYORES_A100 AS SELECT * FROM CANASTA WHERE PRECIO>100;

SELECT * FROM VIEW_CANASTA_MAYORES_A100;

CREATE OR REPLACE VIEW ALUMNO_MATERI AS
SELECT A.NOMBRE AS NOMBRE_ALUMNO,A.APP,M.NOMBRE AS NOBRE_MATERIA,
TO_CHAR(M.HORA_INICIO,'HH24:MI:SS')AS HORA_INICIOM,TO_CHAR(M.HORA_FIN,'HH24:MI:SS') AS HORA_FIN,AM.ID
FROM ALUMNOS A INNER JOIN ALUMS_MATERIAS AM ON A.ID= AM.FK_ALUMNO 
INNER JOIN MATERIAS M ON M.ID = AM.FK_MATERIA;

SELECT * FROM ALUMNO_MATERI;

CREATE OR REPLACE VIEW INFO_PERSONAL AS 
SELECT E.NOMBRE,I.CLAVE AS CLAVE_DEL_LECTOR FROM EMPLEADOS_DOS E INNER JOIN INE I ON E.ID = 1 ORDER BY E.NOMBRE;

SELECT * FROM INFO_PERSONAL;

--------------PROCEDIMIENTO ALMACENADO PLSQL
---ES UN CONJUNTO DE ISTRUCCIONES DE CODIGO SQL QUE NO TIENE VALORES DE RETORNO 
---PUEDE TENER PARAMETROS 
---SE OCUPA AL REALIZAR ISERT, UPDATE O DELET
SELECT * FROM CANASTA;

CREATE OR REPLACE PROCEDURE ELIMINAR_ID_CANASTA
(NUM_IDC CANASTA.ID%TYPE)
AS  
BEGIN 
    DELETE CANASTA WHERE ID=NUM_IDC;
    COMMIT;
END;

EXECUTE ELIMINAR_ID_CANASTA(1);

CREATE OR REPLACE PROCEDURE MODIFICAR_REGISTRO
(NUM_IDC CANASTA.ID%TYPE,NUEVO_PRECIO NUMBER)
AS BEGIN
    UPDATE CANASTA SET PRECIO = NUEVO_PRECIO WHERE ID=NUM_IDC;
END;

EXECUTE MODIFICAR_REGISTRO(2,300);

CREATE OR REPLACE PROCEDURE GURDAR_NUEVO_REGISTRO
(ID_AGREGAR NUMBER,NOMBRE_AGREGAR CANASTA.NOMBRE%TYPE,AGREGAR_PRECIO NUMBER)
AS BEGIN
    INSERT INTO CANASTA VALUES(ID_AGREGAR,NOMBRE_AGREGAR,AGREGAR_PRECIO); 
END;

EXECUTE GURDAR_NUEVO_REGISTRO(1,'REFRESCO',12);

----FUNCIONES ---ES UN BLOQUE DE INTRUCCIONES QUE TIENE VALORES DE RETORNO
---PUDEN TOMAR PARAMETROS 
---PLSQL
---LAS FUNCIONES SE INVOCAN DESDE UNA CONSULTA
---FUNCION QUE CALCULA EL IVA
CREATE OR REPLACE FUNCTION CALCULAR_IVA(VALOR NUMBER)
RETURN NUMBER
IS BEGIN
    RETURN VALOR+(VALOR*0.16);
END;

SELECT NOMBRE,PRECIO,CALCULAR_IVA(PRECIO) AS PRECIO_CON_IVA FROM CANASTA;

----ELIMINACION EN CASCADA 
---SE EAGRAGA CUANDO HAY CARDINALIDAD 
----ES LA ELIMINACION AUTOMATICA DE LAS FILAS O REGISTROS EN TABLAS SECUNDARIAS 
---SE COLOCA EN LAS LAS LLAVES  FORANEAS 
CREATE TABLE NUEVO_CLIENTE(
ID NUMBER PRIMARY KEY,
NOMBRE VARCHAR2(80)NOT NULL,
APP VARCHAR2(80)NOT NULL,
APM VARCHAR2(80)
);

INSERT INTO NUEVO_CLIENTE VALUES (1,'JOSE','ESTRADA','MORALES');

CREATE TABLE TARJETAS(
ID NUMBER PRIMARY KEY,
TIPO VARCHAR2(80)NOT NULL,
FECHA_VEN DATE NOT NULL,
ID_CLIENTE NUMBER NOT NULL,
FOREIGN KEY(ID_CLIENTE) REFERENCES  NUEVO_CLIENTE(ID)
ON DELETE CASCADE---AGREGA LA ELIMINACION EN CASCADA
);

INSERT INTO TARJETAS VALUES(1,'DEBITO','27/03/2026',1);
INSERT INTO TARJETAS VALUES(2,'CREDITO','27/03/2026',1);

DELETE FROM NUEVO_CLIENTE WHERE ID=1; 

SELECT * FROM NUEVO_CLIENTE;

-------------Iniciando con la API REST-----API REST FULL
---Se ocupa la arquitectura cliente servidor
---API REST se ocupa el protocolo http --formar nuestros recursos --Web service Tipo res JSON---
---Metodologi  de desarrolo de software ---SRUM
---Levantamiento de requerimientos
---Arquitecto de software---Decide las tecnologias para el desarrollo
---Desarrollo del lado del servidor 
----Diagrama entidad relacion
---Modelo logico(ya es con un gestor de bases de datos )--normaliazacion de la bases de edatos 
----Logica de la aplicacion: creacion del proyecto, depndencias y demas
---Se ralizan las pruebas unitarias(postman permite realizar puebas unitarias sin tener maquetado)
    ---JUNIT MOCKITO(prubas unitarias desde codigo)
---Desarrollo del lado del cliente 
    ---Crear el proyecto de angular(html,javaScript, ajax,ccs,bostrap)
    ---Realizar las pruebas
    ---Documentacion o manual de usuario
----Pruebas generales o piloto ---3 a 4 dias 
---Cargar el proyecto al servidor(Se enpaqueta el proyecto)

----ApiResTienda 
----Catalogo de productos 
CREATE TABLE PRODUCTOS_PATITO(
    ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    CODIGO_BARRA NUMBER NOT NULL,
    NOMBRE VARCHAR2(100)NOT NULL,
    PRECIO NUMBER NOT NULL,
    STOCK INT NOT NULL,
    CADUCIDAD DATE NOT NULL
);

INSERT INTO PRODUCTOS_PATITO(CODIGO_BARRA,NOMBRE,PRECIO,STOCK,CADUCIDAD) VALUES(435,'BARRITAS',18.50,5,'31/03/2026');
COMMIT;

SELECT * FROM PRODUCTOS_PATITO;

---CREAR,CONFIGURAR,DESARROLLAR,DEISEÑAR,



----ApiRestCinepolis 
CREATE TABLE PELICULAS(
    ID_PELICULA NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    NOMBRE VARCHAR2(80) NOT NULL,
    GENERO VARCHAR2(80)NOT NULL,
    PRECIO NUMBER NOT NULL
);

INSERT INTO PELICULAS (NOMBRE,GENERO,PRECIO)VALUES('BATMAN','ACCION',120);
COMMIT;


SELECT * FROM PELICULAS;

----"Api Agencia "-------
CREATE TABLE MARCAS(
    ID NUMBER PRIMARY KEY,
    NOMBRE VARCHAR2(100)NOT NULL,
    ORIGEN VARCHAR(80)NOT NULL,
    NUM_MODELO INT NOT NULL
);

INSERT INTO MARCAS VALUES(1,'TOLLOTA','JAPON',20);
SELECT * FROM MARCAS;
CREATE TABLE MODELOS(
    ID NUMBER PRIMARY KEY,
    NOMBRE VARCHAR2(100)NOT  NULL,
    PLACA VARCHAR2(20)NOT NULL,
    PRECIO NUMBER NOT NULL,
    FK_MARCA NUMBER NOT NULL,
    FOREIGN KEY(FK_MARCA) REFERENCES MARCAS(ID)
);

INSERT INTO MODELOS VALUES(1,'TACOMA','53698-11',240000,2);
INSERT INTO MODELOS VALUES(2,'COROLA','CPL5369-8',240800,2);
COMMIT;

SELECT * FROM modelos;


-----Aqui se inicia con una arquitectura de microservicios 
---Arquitectura de microservicios para una tienda de 3B

---MS---general o padre ---MS - sucursal--BD---Oracle
CREATE TABLE SUCURSALES_3B(
    ID_SUCURSAL NUMBER PRIMARY KEY,
    NOMBRE VARCHAR2(80) NOT NULL,
    FECHA_APERTURA DATE NOT NULL
);

INSERT INTO  sucursales_3b VALUES (1,'AVENIDA REFORMA NORTE 3B','19/04/2025');
COMMIT;
--NO HAY LLAVE REFENCIADA YA QUE AMBAS TABLAS TENDRIAN QUE ESTAR EN DISTINTOS GESTORES 
---MS---hijos--ms-inventario--BD ----Oracle
CREATE TABLE PRODUCTOS_3B(
    ID_PRODUCTO NUMBER PRIMARY KEY,
    NOMBRE VARCHAR2(100)NOT NULL,
    PRECIO NUMBER NOT NULL,
    ID_SUCURSAL NUMBER NOT NULL ----LLAVE REFERNCIADA  
);

INSERT INTO productos_3b VALUES(1,'FABULOSO',30,2);
COMMIT;

SELECT * FROM PRODUCTOS_3B;

SELECT * FROM SUCURSALES_3B;

---MS-hijo--MS--ventas---h2(es una base de datos en memoria)--Solo para proyectos de prueba
---CLIENTE SERA ESA TABLA LA QUE SE VA A OCUPAR 





























